<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Filesystem Viewer</title>

<style>
body {
    font-family: monospace;
    background: #0f0f0f;
    color: #eaeaea;
    padding: 20px;
}

.hidden {
    display: none;
}

input, button {
    background: #111;
    color: #eaeaea;
    border: 1px solid #444;
    padding: 6px;
}

button:hover {
    background: #222;
}

.file {
    border-bottom: 1px solid #333;
    padding: 8px 0;
    display: flex;
    gap: 8px;
    align-items: center;
}

.path {
    flex: 1;
    word-break: break-all;
}

pre {
    margin-top: 20px;
    background: #000;
    padding: 12px;
    border: 1px solid #333;
    max-height: 60vh;
    overflow: auto;
}

#app {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

/* Header row */
.header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

/* Files panel */
#files {
    max-height: 40vh;
    overflow-y: auto;
    border: 1px solid #ccc;
    padding: 8px;
    margin-bottom: 8px;
}

/* Optional: keep output scrollable as well */
#output {
    flex: 1;
    overflow-y: auto;
}

</style>
</head>

<body>

<!-- LOGIN -->
<form action="/" onsubmit="login()">
    <div id="login">
    <h3>Authenticate</h3>
    <input id="user" placeholder="username" />
    <input id="pass" type="password" placeholder="password" />
    <button onclick="login()">Login</button>
    <div id="login-error"></div>
</div>

</form>
<!-- APP -->
<div id="app" class="hidden">
    <div class="header">
        <h3>Log Files</h3>
        <button onclick="logout()">Logout</button>
    </div>

    <div id="files"></div>
    <pre id="output"></pre>
</div>

<script>
let AUTH_HEADER = null;
let tailInterval = null;

const filesContainer = document.getElementById("files");
const output = document.getElementById("output");

function encodePath(path) {
    return encodeURIComponent(path);
}

function stopFollow() {
    if (tailInterval) {
        clearInterval(tailInterval);
        tailInterval = null;
    }
}

async function authFetch(url) {
    const res = await fetch(url, {
        headers: {
            "Authorization": AUTH_HEADER
        }
    });

    if (!res.ok) {
        throw new Error(res.status + " " + res.statusText);
    }

    return res;
}

async function fetchText(url) {
    const res = await authFetch(url);
    return res.text();
}
async function login() {
    const user = document.getElementById("user").value;
    const pass = document.getElementById("pass").value;

    AUTH_HEADER = "Basic " + btoa(user + ":" + pass);

    try {
        await authFetch("/filesystem/ls");

        // store credentials in localStorage
        localStorage.setItem("auth_user", user);
        localStorage.setItem("auth_pass", pass);

        document.getElementById("login").classList.add("hidden");
        document.getElementById("app").classList.remove("hidden");

        loadFiles();
    } catch (e) {
        document.getElementById("login-error").textContent =
            "Authentication failed";
        AUTH_HEADER = null;
    }
}

function logout() {
    localStorage.removeItem("auth_user");
    localStorage.removeItem("auth_pass");
    AUTH_HEADER = null;
    document.getElementById("login").classList.remove("hidden");
    document.getElementById("app").classList.add("hidden");
    [...filesContainer.children].forEach((a) => filesContainer.removeChild(a));
}

window.addEventListener("load", async () => {
    const user = localStorage.getItem("auth_user");
    const pass = localStorage.getItem("auth_pass");

    if (user && pass) {
        AUTH_HEADER = "Basic " + btoa(user + ":" + pass);
        try {
            await authFetch("/filesystem/ls");
            document.getElementById("login").classList.add("hidden");
            document.getElementById("app").classList.remove("hidden");
            loadFiles();
        } catch (e) {
            // invalid credentials, clear storage
            localStorage.removeItem("auth_user");
            localStorage.removeItem("auth_pass");
            AUTH_HEADER = null;
        }
    }
});

function createFileRow(path) {
    const row = document.createElement("div");
    row.className = "file";

    const pathEl = document.createElement("div");
    pathEl.className = "path";
    pathEl.textContent = path;

    const lines = document.createElement("input");
    lines.type = "number";
    lines.min = 1;
    lines.value = 10;


    const cat = document.createElement("button");
    cat.textContent = "cat";
    cat.onclick = async () => {
        stopFollow();
        output.textContent = await fetchText(
            `/filesystem/cat?path=${encodePath(path)}`
        );
    };

    const head = document.createElement("button");
    head.textContent = "head";
    head.onclick = async () => {
        stopFollow();
        output.textContent = await fetchText(
            `/filesystem/head?path=${encodePath(path)}&lines=${lines.value}`
        );
    };
    const follow = document.createElement("input");
    follow.type = "checkbox";
    follow.title = "Follow the output when using tail"
    const tail = document.createElement("button");
    tail.textContent = "tail";
    tail.onclick = async () => {
    stopFollow();
    output.textContent = "";

    const url = `/filesystem/tail?path=${encodePath(path)}&lines=${lines.value}&follow=${follow.checked}`;

    if (!follow.checked) {
        // normal tail, not streaming
        output.textContent = await fetchText(url);
        return;
    }

    try {
        const res = await authFetch(url); // includes Basic Auth
        const reader = res.body.getReader();
        const decoder = new TextDecoder();

        async function readChunk() {
            const { done, value } = await reader.read();
            if (done) return;  // stream closed
            output.textContent += decoder.decode(value, { stream: true });
            output.scrollTop = output.scrollHeight; // auto-scroll
            readChunk(); // continue reading
        }

        readChunk();
    } catch (e) {
        output.textContent += "\n[Error: " + e.message + "]";
    }
};

    row.append(pathEl, lines,  cat, head, tail,follow,);
    return row;
}

async function loadFiles() {
    const res = await authFetch("/filesystem/ls");
    const files = await res.json();

    files.forEach(f => filesContainer.appendChild(createFileRow(f)));
}
</script>

</body>
</html>
